```c
bool FUN_14000b1f0(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4)
{
    int iVar1;               // Variável para armazenar o resultado da comparação
    char *pcVar2;           // Ponteiro para string, usado em algumas chamadas
    undefined1 (*pauVar3) [10];   // Ponteiro para uma string/array (provavelmente algo criptografado)
    float10 local_27;       // Variável onde o resultado da função será armazenado

    // Chamada para a função de inicialização
    FUN_14000153e();

    // Configuração de pauVar3 com um endereço específico (provavelmente é um buffer)
    pauVar3 = (undefined1 (*) [10])0x54;

    // Chama uma função que provavelmente manipula ou retorna uma string criptografada
    pcVar2 = (char *)FUN_14000148a("1: 1&t <1t$5\'\'#;&0ntT4q\'4Tqgf\'TTe 7", 0x54);

    // Passa o valor de pcVar2, pauVar3, param_3 e param_4 para uma outra função
    FUN_140001400(pcVar2, pauVar3, param_3, param_4);

    // Chama uma outra função para manipular ou preencher local_27 com dados de param_3 e param_4
    FUN_140001447(&DAT_14000d000, &local_27, param_3, param_4);

    // Altera o ponteiro pauVar3 para outro valor com uma string diferente
    pauVar3 = (undefined1 (*) [10])FUN_14000148a("\"gpPGcG*+wBq}b]VP[Zdy$ej\\jyj\"g", 0x13);

    // Compara a string em local_27 com a string apontada por pauVar3 (provavelmente uma senha ou flag criptografada)
    iVar1 = strcmp((char *)&local_27, (char *)pauVar3);

    // Se a comparação falhar, imprime "Wrong password!", senão "Correct password!"
    if (iVar1 != 0) {
        FUN_140001400("Wrong password!\n", pauVar3, param_3, param_4);
    } else {
        FUN_140001400("Correct password!\n", pauVar3, param_3, param_4);
    }

    // Retorna 1 (senha incorreta) ou 0 (senha correta)
    return iVar1 != 0;
}

```

```c
void * FUN_14000148a(char *param_1, byte param_2)
{
  size_t sVar1;
  void *pvVar2;
  longlong lVar3;

  // Calcula o tamanho da string de entrada
  sVar1 = strlen(param_1);
  
  // Aloca memória suficiente para armazenar a string resultante
  pvVar2 = malloc(sVar1);
  
  // Loop para percorrer cada caractere da string e fazer uma operação XOR com param_2
  for (lVar3 = 0; param_1[lVar3] != 0; lVar3 = lVar3 + 1) {
    *(byte *)((longlong)pvVar2 + lVar3) = param_1[lVar3] ^ param_2;
  }

  // Adiciona o terminador nulo ao final da string resultante
  sVar1 = strlen(param_1);
  *(undefined *)((longlong)pvVar2 + sVar1) = 0;

  return pvVar2;
}

```


```c
void FUN_140001447(undefined8 param_1, float10 *param_2, undefined8 param_3, undefined8 param_4)
{
  undefined8 uVar1;
  float10 *local_res10;
  undefined8 local_res18;
  undefined8 local_res20;

  // Atribui os parâmetros para variáveis locais
  local_res10 = param_2;
  local_res18 = param_3;
  local_res20 = param_4;

  // Chama uma função externa (provavelmente retorna um valor necessário)
  uVar1 = (*(code *)PTR_FUN_14000c110)(0);
  
  // Passa os resultados de volta para uma outra função
  FUN_140004848(uVar1, (undefined4 *)&DAT_14000d000, &local_res10);
  
  return;
}

```

```c
void FUN_140004848(undefined8 param_1, undefined4 *param_2, float10 **param_3) {
    longlong lVar1;
    ulonglong uVar2;
    longlong lVar3;
    FILE **ppFVar4;
    FILE *pFStackX_20;
    undefined8 uStack_10;

    uStack_10 = 0x140004853;  // Inicializa a variável uStack_10 com o valor 0x140004853

    uVar2 = FUN_140002130();  // Chama a função FUN_140002130 e armazena o resultado em uVar2
    lVar1 = -uVar2;  // Inverte o valor de uVar2 e armazena em lVar1

    ppFVar4 = (FILE **)((longlong)&pFStackX_20 + lVar1);  // Calcula o endereço de ppFVar4 baseado em pFStackX_20 e lVar1

    // Loop para inicializar uma estrutura de 0x406 elementos (provavelmente arquivos ou ponteiros)
    for (lVar3 = 0x406; lVar3 != 0; lVar3 = lVar3 - 1) {
        *(undefined4 *)ppFVar4 = 0;  // Inicializa o valor em ppFVar4 para 0
        ppFVar4 = (FILE **)((longlong)ppFVar4 + 4);  // Move o ponteiro ppFVar4 para o próximo endereço
    }

    *(undefined8 *)((longlong)&pFStackX_20 + lVar1) = param_1;  // Atribui param_1 ao local calculado de pFStackX_20
    *(undefined8 *)((longlong)&uStack_10 + lVar1) = 0x140004877;  // Atribui o valor 0x140004877 ao local calculado de uStack_10

    // Chama a função FUN_140002442 com os parâmetros ajustados
    FUN_140002442((FILE **)((longlong)&pFStackX_20 + lVar1), param_2, param_3);
    return;
}
```

```c
void FUN_14000153e(void) {
    // Verifica se a variável global `DAT_140011040` é igual a zero
    if (DAT_140011040 == 0) {
        // Se for zero, define `DAT_140011040` como 1
        DAT_140011040 = 1;

        // Chama a função `FUN_1400014f4()`
        FUN_1400014f4();
        return;  // Finaliza a função
    }

    // Se `DAT_140011040` não for zero, não faz nada e apenas retorna
    return;
}

```

```c
void FUN_1400014f4(void) {
    ulonglong uVar1;
    ulonglong uVar2;
    code **ppcVar3;  // Ponteiro para ponteiros de funções

    uVar1 = 0;

    // === Primeiro loop: Determinar o tamanho da tabela de funções ===
    do {
        uVar2 = uVar1;  // Salva o valor atual de `uVar1` em `uVar2`
        uVar1 = (ulonglong)((int)uVar2 + 1);  // Incrementa `uVar1`
    } while ((&DAT_14000b280)[uVar1] != 0);  
    // Continua até encontrar um elemento nulo na tabela `DAT_14000b280`

    // === Segundo loop: Executar funções na tabela ===
    for (ppcVar3 = (code **)(&DAT_14000b280 + uVar2); 
         ppcVar3 != (code **)&DAT_14000b280; 
         ppcVar3 = ppcVar3 - 1) {
        (**ppcVar3)();  // Chama cada função na tabela
    }

    // === Registrar uma função para ser chamada na finalização ===
    FUN_1400013d7((_onexit_t)&LAB_1400014d0);

    return;
}
```

```

```

```

```
