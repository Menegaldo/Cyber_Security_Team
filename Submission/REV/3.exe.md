# 3.exe

###### Resolvido por @Menegaldo
> Este é um CTF sobre [Use After Free]  

## Sobre o Desafio  

Apenas o arquivo: 3.exe

## Solução

Rodando o executavel

![image](https://github.com/user-attachments/assets/b58fb86f-cc22-4ddf-8e87-c06c865780ff)

colocando algo no campo de entrada

![image](https://github.com/user-attachments/assets/4715885e-2492-4b44-92e6-a9f26523c338)

indo no ghidra e localizando o pesquisando por "wrong password"

![image](https://github.com/user-attachments/assets/10de96f4-3abd-4963-8500-0b1d9d467895)

analisando o codigo:

```c
bool FUN_14000b1f0(void)

{
  int iVar1;
  undefined8 uVar2;
  char *_Str2;
  char local_27 [31];
  
  FUN_14000153e();
  uVar2 = FUN_14000148a("1: 1&t <1t$5\'\'#;&0ntT4q\'4Tqgf\'TTe 7",0x54);
  FUN_140001400(uVar2);
  FUN_140001447(&DAT_14000d000,local_27);
  _Str2 = (char *)FUN_14000148a("\"gpPGcG*+wBq}b]VP[Zdy$ej\\jyj\"g",0x13);
  iVar1 = strcmp(local_27,_Str2);
  if (iVar1 != 0) {
    FUN_140001400("Wrong password!\n");
  }
  else {
    FUN_140001400("Correct password!\n");
  }
  return iVar1 != 0;
}
```

Podemos ver que o seguinte:

`FUN_14000148a("1: 1&t <1t$5''#;&0ntT4q'4Tqgf'TTe 7", 0x54)`: Essa chamada usa a string `"1: 1&t <1t$5''#;&0ntT4q'4Tqgf'TTe 7"` e a chave `0x54` (84 em decimal).

`FUN_14000148a("\"gpPGcG*+wBq}b]VP[Zdy$ej\\jyj\"g", 0x13)`: Essa chamada usa a string `"gpPGcG*+wBq}b]VP[Zdy$ej\jyj"g"` e a chave `0x13` (19 em decimal). O resultado é armazenado em `_Str2`.

Se forem diferentes → `Wrong password!`
Se forem iguais → `Correct password!`


```c
void * FUN_14000148a(char *param_1,byte param_2)

{
  size_t sVar1;
  void *pvVar2;
  longlong lVar3;
  
  sVar1 = strlen(param_1);
  pvVar2 = malloc(sVar1);
  for (lVar3 = 0; param_1[lVar3] != 0; lVar3 = lVar3 + 1) {
    *(byte *)((longlong)pvVar2 + lVar3) = param_1[lVar3] ^ param_2;
  }
  sVar1 = strlen(param_1);
  *(undefined *)((longlong)pvVar2 + sVar1) = 0;
  return pvVar2;
}
```

`FUN_14000148a()` (Função de decodificação)

Essa função percorre cada caractere da string `param_1`.
Para cada caractere, ela aplica um `XOR` com o valor `param_2`.

O resultado é armazenado em um buffer e retornado.

codigo em python que gera a senha com base nas informações anteriores.

```py
def xor_string(encoded_str, key):
    decoded_str = ''.join([chr(ord(c) ^ key) for c in encoded_str])
    return decoded_str

# Exemplo de strings codificadas
encoded_str_1 = "1: 1&t <1t$5\'\'#;&0ntT4q\'4Tqgf\'TTe 7"
encoded_str_2 = "\"gpPGcG*+wBq}b]VP[Zdy$ej\\jyj\"g"

# Vamos tentar reverter o XOR usando um valor chave (no seu caso, o valor de param_2)
key_1 = 0x54  # Exemplo de chave, precisa ser ajustada com base no que você encontrar
key_2 = 0x13  # Outra chave possível

decoded_1 = xor_string(encoded_str_1, key_1)
decoded_2 = xor_string(encoded_str_2, key_2)

print("Decoded string 1:", decoded_1)
print("Decoded string 2:", decoded_2)
```
saida do codigo com a senha correta.

![image](https://github.com/user-attachments/assets/25af7f3a-40f1-4f1c-8af7-dabc6bc83021)

> Assim, obtemos a flag `1tcCTpT98dQbnqNECHIwj7vyOyjy1t`
