Este executável solicita uma senha do usuário, compara com um valor esperado e exibe uma mensagem dependendo da verificação.

![image](https://github.com/user-attachments/assets/283897f1-f2d2-4fd5-9f1f-be3f32f7cc03)

inserir algo no campo de entrada

![image](https://github.com/user-attachments/assets/4408f75c-5df7-4abd-b615-33cdbe625bc6)


```c
undefined8 FUN_001010c0(void)

{
  long in_FS_OFFSET;
  int local_118;
  short local_114;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __printf_chk(1,"Enter the password: ");
  __isoc99_scanf("%255s",&local_118);
  if ((local_118 == 0x30783468) && (local_114 == 0x72)) {
    puts("Good boy!");
  }
  else {
    puts("Bad boy!");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}
```

Este código é uma função em C que parece ser parte de um programa que recebe uma senha do usuário e a compara com um valor esperado. Aqui está uma explicação simples e direta de como ele funciona:

Definição da função: A função FUN_001010c0 é definida, e dentro dela há uma verificação de segurança de pilha (__stack_chk_fail).

Leitura da senha:

O programa imprime "Enter the password: ".
Ele lê a entrada do usuário com __isoc99_scanf("%255s", &local_118), que espera uma string de até 255 caracteres.
Verificação da senha:

O valor lido é armazenado em local_118.
Depois, o programa compara o valor de local_118 com 0x30783468 e local_114 com 0x72.
Se local_118 == 0x30783468 e local_114 == 0x72, ele imprime "Good boy!".
Caso contrário, imprime "Bad boy!".
Verificação de segurança de pilha:

A função verifica se o valor de local_10 é igual ao valor que estava armazenado no início de local_10 (presumivelmente no início da função).
Se essa verificação falhar (o que indica uma violação de segurança, como uma modificação no conteúdo da pilha), a função chama __stack_chk_fail() para abortar o programa de forma segura.

```py
import subprocess

# Gerando a senha em little endian
print("[+] Gerando a senha em formato hexadecimal (little endian)...")
senha = bytearray.fromhex('68 34 78 30')  # 0x30783468 em little endian
print(f"[+] Senha gerada (bytes): {senha.hex()}")

# Adicionando o caractere 'r' (0x72)
print("[+] Adicionando o caractere 'r'...")
senha.append(0x72)
print(f"[+] Senha completa (bytes): {senha.hex()}")

# Convertendo para string (modo seguro para manter os bytes)
senha_str = senha.decode('latin1')
print(f"[+] Senha convertida para string: {senha_str.encode('latin1').hex()}")

# Executando o binário '4' e enviando a senha como entrada
print("[+] Executando o executável '4' e enviando a senha...")
process = subprocess.Popen("./4", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
stdout, stderr = process.communicate(input=senha_str.encode('latin1'))

# Exibindo a saída do executável
print("[+] Saída do executável:")
print(stdout.decode())
if stderr:
    print("[ERRO]", stderr.decode())
```


![image](https://github.com/user-attachments/assets/04103ec3-83d4-4b55-9d9e-f3aa0df3f301)

A senha 6834783072 que aparece no seu código e na saída está em formato hexadecimal (representada por 0x6834783072), que é a forma que os bytes são manipulados.

Aqui está o passo a passo do que ocorre no código para chegar a essa senha:

Senha original em Little Endian:

Você começa com a sequência de bytes 68 34 78 30 que representa o valor 0x30783468 em Little Endian. Little Endian é uma forma de armazenar os bytes de um número onde o byte menos significativo (LSB) vem primeiro.
Isso significa que os bytes 68 34 78 30 são lidos como 0x30783468 em Big Endian (ordem normal), mas em Little Endian eles são armazenados como 0x68347830.
Adicionando o caractere 'r':

O valor hexadecimal 0x72 corresponde ao caractere 'r' em ASCII.
Você adiciona esse byte à sequência, fazendo a senha ser 0x6834783072, onde:
68 34 78 30 (a senha original em Little Endian)
72 (o byte que representa o caractere 'r').
Senha em formato hexadecimal:

A senha final, após a adição do caractere 'r', é 6834783072 em hexadecimal. Ou seja, a sequência de bytes é 68 34 78 30 72.
Convertendo para string:

Ao converter essa sequência de bytes para uma string usando a codificação 'latin1', você mantém a correspondência exata dos bytes em sua representação de caracteres.
O método .decode('latin1') não altera os bytes, ele os interpreta como caracteres de uma tabela de codificação, e depois você os converte novamente para hexadecimal (encode('latin1').hex()).
Portanto, a senha 6834783072 representa, em termos de bytes:

0x68 = 'h'
0x34 = '4'
0x78 = 'x'
0x30 = '0'
0x72 = 'r'

Quando convertida para string, você tem algo como h4x0r com o byte 0x72 no final, representando a letra 'r'.

![image](https://github.com/user-attachments/assets/11b5dbef-f4d9-45ef-bea1-2d77df4550b1)

